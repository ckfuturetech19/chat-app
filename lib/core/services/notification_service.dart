import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:onesignal_flutter/onesignal_flutter.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';
import 'firebase_service.dart';
import 'pressence_service.dart';

class NotificationService {
  static const String _oneSignalAppId = "7d95dd17-81f9-4090-a80c-f849a182de99";
  static const String _oneSignalRestApiKey =
      "os_v2_app_pwk52f4b7fajbkam7be2daw6thcqgldxmiwuxznkwlugxfa66ahqgd4e25o5vrjnuy2cri7xb6ve2qpazujoegedxwiynosvw522gsa";
  static const String _oneSignalApiUrl =
      "https://onesignal.com/api/v1/notifications";

  // Validate API key format
  static bool _isValidApiKey(String apiKey) {
    // OneSignal REST API keys should be 32+ characters
    return apiKey.isNotEmpty && apiKey.length >= 20;
  }

  // Initialize OneSignal with enhanced setup
  static Future<void> initialize() async {
    try {
      print('üîç Initializing OneSignal with App ID: $_oneSignalAppId');

      OneSignal.initialize(_oneSignalAppId);
      await OneSignal.Notifications.requestPermission(true);
      _setupNotificationHandlers();
      await updateUserPlayerId();

      print('‚úÖ OneSignal initialized successfully');
    } catch (e) {
      print('‚ùå OneSignal initialization error: $e');
    }
  }

  static void _setupNotificationHandlers() {
    OneSignal.Notifications.addForegroundWillDisplayListener((event) {
      print(
        'üì± Notification received in foreground: ${event.notification.title}',
      );

      final additionalData = event.notification.additionalData;
      final notificationType = additionalData?['type'] as String?;

      if (notificationType == 'new_message') {
        final chatId = additionalData?['chatId'] as String?;

        // ENHANCED: Check if user is currently viewing this specific chat
        if (_isUserViewingChat(chatId)) {
          print('üì± User is viewing chat, not showing notification');
          return; // Don't display notification
        }
      }

      // Display notification if user is not in the specific chat
      event.notification.display();
    });

    OneSignal.Notifications.addClickListener((event) {
      print('üîî Notification clicked: ${event.notification.title}');
      final additionalData = event.notification.additionalData;
      if (additionalData != null) {
        _handleNotificationClick(additionalData);
      }
    });

    OneSignal.Notifications.addPermissionObserver((state) {
      print('üîî Notification permission state: $state');
      if (state) updateUserPlayerId();
    });

    OneSignal.User.pushSubscription.addObserver((state) {
      print('üîî Push subscription changed: ${state.current.id}');
      if (state.current.id != null) updateUserPlayerId();
    });
  }

  // Track current active chat
  static String? _currentActiveChatId;
  static bool _isAppInForeground = true;

  // Set current active chat ID
  static void setActiveChatId(String? chatId) {
    _currentActiveChatId = chatId;
    print('üì± Active chat set to: $chatId');
  }

  // Set app foreground state
  static void setAppForegroundState(bool isInForeground) {
    _isAppInForeground = isInForeground;
    print('üì± App foreground state: $isInForeground');
  }

  // Check if user is viewing specific chat
  static bool _isUserViewingChat(String? chatId) {
    if (!_isAppInForeground) return false;
    if (chatId == null || _currentActiveChatId == null) return false;
    return _currentActiveChatId == chatId;
  }

  static void _handleNotificationClick(Map<String, dynamic> data) {
    final type = data['type'] as String?;
    final chatId = data['chatId'] as String?;
    final senderId = data['senderId'] as String?;

    switch (type) {
      case 'new_message':
        if (chatId != null) {
          print('üì± Opening chat: $chatId from sender: $senderId');
          _navigateToChat(chatId, senderId);
        }
        break;
      case 'typing':
        print('‚úçÔ∏è Partner is typing in chat: $chatId');
        break;
      case 'connection_request':
        print('ü§ù New connection request');
        break;
      default:
        print('üì± Unknown notification type: $type');
    }
  }

  static void _navigateToChat(String chatId, String? senderId) {
    print('üß≠ Navigation intent: Chat $chatId');
    // TODO: Implement navigation logic here
    // You might want to use a global navigation key or route management
  }

  static Future<String?> getPlayerId() async {
    try {
      for (int attempt = 0; attempt < 5; attempt++) {
        final playerId = OneSignal.User.pushSubscription.id;
        if (playerId != null && playerId.isNotEmpty) {
          print('‚úÖ OneSignal Player ID obtained: $playerId');
          return playerId;
        }

        print('‚è≥ Attempt ${attempt + 1}: Waiting for OneSignal Player ID...');
        await Future.delayed(Duration(seconds: (attempt + 1) * 2));
      }

      print('‚ö†Ô∏è Could not get OneSignal player ID after 5 attempts');
      return null;
    } catch (e) {
      print('‚ùå Error getting OneSignal player ID: $e');
      return null;
    }
  }

  static Future<void> updateUserPlayerId() async {
    try {
      final playerId = await getPlayerId();
      final currentUser = FirebaseService.currentUser;

      if (playerId != null && currentUser != null) {
        await FirebaseService.usersCollection.doc(currentUser.uid).update({
          'oneSignalPlayerId': playerId,
          'notificationEnabled': true,
          'lastPlayerIdUpdate': FieldValue.serverTimestamp(),
          'updatedAt': FieldValue.serverTimestamp(),
        });

        print('‚úÖ OneSignal Player ID updated in Firestore: $playerId');
      } else {
        print(
          '‚ö†Ô∏è Could not update player ID - playerId: $playerId, user: ${currentUser?.uid}',
        );

        if (playerId == null) {
          print('üîÑ Retrying player ID update in 5 seconds...');
          Future.delayed(const Duration(seconds: 5), () {
            updateUserPlayerId();
          });
        }
      }
    } catch (e) {
      print('‚ùå Error updating OneSignal Player ID: $e');
      Future.delayed(const Duration(seconds: 5), () {
        updateUserPlayerId();
      });
    }
  }

  // ENHANCED: Direct REST API notification sending for instant delivery
  static Future<bool> sendInstantMessageNotification({
    required String recipientPlayerId,
    required String senderName,
    required String message,
    required String chatId,
    required String senderId,
    bool skipPresenceCheck =
        false, // Allow bypassing presence check for testing
  }) async {
    try {
      print('üöÄ Sending INSTANT notification via REST API...');
      print('üìù To Player ID: $recipientPlayerId');
      print('üìù From: $senderName');
      print('üìù Message: $message');
      print('üìù Chat ID: $chatId');
      print('üìù Sender ID: $senderId');

      // Check if notification should be sent (skip for testing)
      if (!skipPresenceCheck) {
        final shouldSendNotification = await _shouldSendNotification(
          recipientPlayerId: recipientPlayerId,
          chatId: chatId,
          senderId: senderId,
        );

        if (!shouldSendNotification) {
          print('üì± Skipping notification - recipient is active in chat');
          return false;
        }
      } else {
        print('üß™ Skipping presence check for testing');
      }

      // Format message for notification
      String notificationMessage = message;
      if (message.length > 100) {
        notificationMessage = '${message.substring(0, 97)}...';
      }

      // Handle special message types
      if (message.startsWith('üì∑')) {
        notificationMessage = 'üì∑ Sent a photo';
      } else if (message.isEmpty) {
        notificationMessage = 'Sent a message';
      }

      print('üîß Creating notification payload...');

      // Create notification payload for OneSignal REST API
      final Map<String, dynamic> notificationPayload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': [recipientPlayerId],
        'headings': {'en': 'üíï $senderName'},
        'contents': {'en': notificationMessage},
        'data': {
          'type': 'new_message',
          'chatId': chatId,
          'senderId': senderId,
          'senderName': senderName,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'messagePreview': notificationMessage,
        },
        'priority': 10, // High priority
        'ttl': 259200, // 3 days
        // Remove android_channel_id - let OneSignal use default
        // 'android_channel_id': 'high_importance_channel',
        'android_accent_color': 'FF9C27B0',
        'android_led_color': 'FF9C27B0',
        'android_sound': 'default',
        'ios_sound': 'default',
        'ios_badgeType': 'Increase',
        'ios_badgeCount': 1,
      };

      print('üì° Sending HTTP request to OneSignal...');
      print('üîó URL: $_oneSignalApiUrl');
      print('üîë API Key Length: ${_oneSignalRestApiKey.length}');
      print('üîë API Key Valid: ${_isValidApiKey(_oneSignalRestApiKey)}');
      print('üîë App ID: $_oneSignalAppId');
      print('üì¶ Payload: ${jsonEncode(notificationPayload)}');

      // Validate API key before sending
      if (!_isValidApiKey(_oneSignalRestApiKey)) {
        print('‚ùå Invalid API key format');
        return false;
      }

      print('üöÄ Making HTTP POST request...');

      // Send notification via REST API with timeout
      final response = await http
          .post(
            Uri.parse(_oneSignalApiUrl),
            headers: {
              'Content-Type': 'application/json; charset=utf-8',
              'Authorization': 'Basic $_oneSignalRestApiKey',
              'Accept': 'application/json',
            },
            body: jsonEncode(notificationPayload),
          )
          .timeout(
            const Duration(seconds: 30),
            onTimeout: () {
              print('‚è∞ HTTP request timed out after 30 seconds');
              throw Exception('Request timed out');
            },
          );

      print('üì® HTTP request completed!');
      print('üìã HTTP Response Status: ${response.statusCode}');
      print('üìã HTTP Response Headers: ${response.headers}');
      print('üìã HTTP Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        print('‚úÖ INSTANT notification sent successfully!');
        print('üìä OneSignal ID: ${responseData['id']}');
        print('üìä Recipients: ${responseData['recipients']}');
        print('üìä External ID: ${responseData['external_id']}');

        // Also update unread count (skip for testing)
        if (!skipPresenceCheck) {
          await _updateUnreadCount(recipientPlayerId, chatId);
        }

        // Store notification record for tracking
        await _storeNotificationRecord(
          recipientPlayerId: recipientPlayerId,
          senderName: senderName,
          message: notificationMessage,
          chatId: chatId,
          senderId: senderId,
          oneSignalId: responseData['id'] ?? 'unknown',
          recipients: responseData['recipients'] ?? 0,
        );

        return true;
      } else {
        print('‚ùå Failed to send notification: ${response.statusCode}');
        print('‚ùå Response Headers: ${response.headers}');
        print('‚ùå Response Body: ${response.body}');

        // Try to parse error response
        try {
          final errorData = jsonDecode(response.body);
          if (errorData['errors'] != null) {
            print('‚ùå OneSignal Errors: ${errorData['errors']}');
          }
        } catch (e) {
          print('‚ùå Could not parse error response: $e');
        }

        return false;
      }
    } catch (e, stackTrace) {
      print('‚ùå Error sending instant notification: $e');
      print('‚ùå Stack trace: $stackTrace');
      return false;
    }
  }

  // Store notification record for tracking and analytics
  static Future<void> _storeNotificationRecord({
    required String recipientPlayerId,
    required String senderName,
    required String message,
    required String chatId,
    required String senderId,
    required String oneSignalId,
    required int recipients,
  }) async {
    try {
      await FirebaseService.firestore.collection('notificationLogs').add({
        'type': 'new_message',
        'recipientPlayerId': recipientPlayerId,
        'senderName': senderName,
        'message': message,
        'chatId': chatId,
        'senderId': senderId,
        'oneSignalId': oneSignalId,
        'recipients': recipients,
        'status': 'sent',
        'method': 'rest_api_instant',
        'sentAt': FieldValue.serverTimestamp(),
        'appId': _oneSignalAppId,
      });

      print('‚úÖ Notification record stored');
    } catch (e) {
      print('‚ùå Error storing notification record: $e');
    }
  }

  // FALLBACK: Original Firestore method as backup
  static Future<void> sendMessageNotification({
    required String recipientPlayerId,
    required String senderName,
    required String message,
    required String chatId,
    required String senderId,
  }) async {
    // First try instant REST API method
    final instantSuccess = await sendInstantMessageNotification(
      recipientPlayerId: recipientPlayerId,
      senderName: senderName,
      message: message,
      chatId: chatId,
      senderId: senderId,
    );

    // If instant method fails, use Firestore backup
    if (!instantSuccess) {
      print('üîÑ Instant notification failed, using Firestore backup...');
      await _sendFirestoreNotification(
        recipientPlayerId: recipientPlayerId,
        senderName: senderName,
        message: message,
        chatId: chatId,
        senderId: senderId,
      );
    }
  }

  // Original Firestore method as backup
  static Future<void> _sendFirestoreNotification({
    required String recipientPlayerId,
    required String senderName,
    required String message,
    required String chatId,
    required String senderId,
  }) async {
    try {
      print('üì§ Creating Firestore notification request...');

      // Format message for notification
      String notificationMessage = message;
      if (message.length > 100) {
        notificationMessage = '${message.substring(0, 97)}...';
      }

      // Handle special message types
      if (message.startsWith('üì∑')) {
        notificationMessage = 'üì∑ Sent a photo';
      } else if (message.isEmpty) {
        notificationMessage = 'Sent a message';
      }

      // Create notification request with enhanced data
      await FirebaseService.firestore.collection('notificationRequests').add({
        'type': 'new_message',
        'recipientPlayerId': recipientPlayerId,
        'title': 'üíï $senderName',
        'message': notificationMessage,
        'additionalData': {
          'type': 'new_message',
          'chatId': chatId,
          'senderId': senderId,
          'senderName': senderName,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'messagePreview': notificationMessage,
        },
        'status': 'pending',
        'createdAt': FieldValue.serverTimestamp(),
        'appId': _oneSignalAppId,
        'priority': 'high',
        'sound': 'default',
        'badge': 1,
      });

      print('‚úÖ Firestore notification request created');
    } catch (e) {
      print('‚ùå Error creating Firestore notification request: $e');
    }
  }

  // ENHANCED: Send typing notification instantly
  static Future<bool> sendTypingNotification({
    required String recipientPlayerId,
    required String senderName,
    required String chatId,
    required String senderId,
  }) async {
    try {
      print('‚úçÔ∏è Sending typing notification...');

      // Create typing notification payload
      final Map<String, dynamic> notificationPayload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': [recipientPlayerId],
        'headings': {'en': '‚úçÔ∏è $senderName'},
        'contents': {'en': 'is typing...'},
        'data': {
          'type': 'typing',
          'chatId': chatId,
          'senderId': senderId,
          'senderName': senderName,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
        },
        'priority': 5, // Lower priority for typing
        'ttl': 30, // Short TTL for typing notifications
        // Remove android_channel_id
        // 'android_channel_id': 'typing_channel',
        'delayed_option': 'immediate',
      };

      final response = await http.post(
        Uri.parse(_oneSignalApiUrl),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Authorization': 'Basic $_oneSignalRestApiKey',
        },
        body: jsonEncode(notificationPayload),
      );

      if (response.statusCode == 200) {
        print('‚úÖ Typing notification sent successfully!');
        return true;
      } else {
        print('‚ùå Failed to send typing notification: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending typing notification: $e');
      return false;
    }
  }

  // ENHANCED: Batch send notifications to multiple recipients
  static Future<bool> sendBatchNotifications({
    required List<String> recipientPlayerIds,
    required String title,
    required String message,
    required Map<String, dynamic> additionalData,
  }) async {
    try {
      print(
        'üì¢ Sending batch notification to ${recipientPlayerIds.length} recipients...',
      );

      final Map<String, dynamic> notificationPayload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': recipientPlayerIds,
        'headings': {'en': title},
        'contents': {'en': message},
        'data': additionalData,
        'priority': 10,
        'ttl': 259200,
        // Remove android_channel_id for compatibility
        // 'android_channel_id': 'high_importance_channel',
        'ios_badgeType': 'Increase',
        'ios_badgeCount': 1,
      };

      final response = await http.post(
        Uri.parse(_oneSignalApiUrl),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Authorization': 'Basic $_oneSignalRestApiKey',
        },
        body: jsonEncode(notificationPayload),
      );

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        print('‚úÖ Batch notification sent successfully!');
        print('üìä Recipients: ${responseData['recipients']}');
        return true;
      } else {
        print('‚ùå Failed to send batch notification: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error sending batch notification: $e');
      return false;
    }
  }

  // Enhanced logic to determine if notification should be sent
  static Future<bool> _shouldSendNotification({
    required String recipientPlayerId,
    required String chatId,
    required String senderId,
  }) async {
    try {
      print('üîç Checking if notification should be sent...');

      // Get recipient user ID from player ID mapping
      final recipientUserId = await _getRecipientUserIdFromPlayerId(
        recipientPlayerId,
      );

      if (recipientUserId == null) {
        print('‚ö†Ô∏è Could not find user ID for player ID: $recipientPlayerId');
        print('‚úÖ Sending notification anyway (default behavior)');
        return true; // Send notification anyway since we can't check status
      }

      print(
        '‚úÖ Found recipient user ID: $recipientUserId for player ID: $recipientPlayerId',
      );

      // Check if recipient user document exists with timeout
      try {
        final recipientDoc = await FirebaseService.usersCollection
            .doc(recipientUserId)
            .get()
            .timeout(const Duration(seconds: 5));

        if (!recipientDoc.exists) {
          print('‚ö†Ô∏è Recipient user document not found for: $recipientUserId');
          print('‚úÖ Sending notification anyway (document not found)');
          return true; // Send notification anyway
        }

        final recipientData = recipientDoc.data() as Map<String, dynamic>;

        // Check if recipient is actively viewing this specific chat
        final recipientActiveChat = recipientData['activeChatId'] as String?;
        if (recipientActiveChat != chatId) {
          print(
            'üì± Recipient is not viewing this chat (active: $recipientActiveChat, target: $chatId)',
          );
          print('‚úÖ Sending notification - different chat');
          return true;
        }

        // Check app state
        final isRecipientAppInBackground =
            recipientData['isAppInBackground'] as bool? ?? false;
        if (isRecipientAppInBackground) {
          print('üì± Recipient app is in background');
          print('‚úÖ Sending notification - app in background');
          return true;
        }

        // Try to check if recipient is online with timeout (non-blocking)
        try {
          final isRecipientOnline = await PresenceService.instance
              .isUserOnline(recipientUserId)
              .timeout(const Duration(seconds: 3));

          if (!isRecipientOnline) {
            print('üì± Recipient is offline');
            print('‚úÖ Sending notification - user offline');
            return true;
          }

          // Check when was recipient last seen with timeout
          try {
            final lastSeen = await PresenceService.instance
                .getUserLastSeen(recipientUserId)
                .timeout(const Duration(seconds: 3));

            if (lastSeen != null) {
              final timeSinceLastSeen = DateTime.now().difference(lastSeen);

              // If last seen more than 30 seconds ago, send notification
              if (timeSinceLastSeen.inSeconds > 30) {
                print(
                  'üì± Recipient last seen ${timeSinceLastSeen.inSeconds}s ago',
                );
                print('‚úÖ Sending notification - last seen > 30s ago');
                return true;
              }
            }
          } catch (e) {
            print('‚ö†Ô∏è Timeout getting last seen: $e');
            print('‚úÖ Sending notification anyway (timeout on last seen)');
            return true;
          }
        } catch (e) {
          print('‚ö†Ô∏è Timeout checking online status: $e');
          print('‚úÖ Sending notification anyway (timeout on presence check)');
          return true;
        }

        print('üì± Recipient is active in this chat and app is in foreground');
        print('‚ùå Skipping notification - user is actively viewing chat');
        return false;
      } catch (e) {
        print('‚ö†Ô∏è Timeout getting user document: $e');
        print('‚úÖ Sending notification anyway (timeout on document fetch)');
        return true;
      }
    } catch (e) {
      print('‚ùå Error checking notification conditions: $e');
      print('‚úÖ Sending notification anyway (default on error)');
      return true; // Default to sending notification on error
    }
  }

  // Update unread message count for user
  static Future<void> _updateUnreadCount(
    String recipientPlayerId,
    String chatId,
  ) async {
    try {
      final recipientUserId = await _getRecipientUserIdFromPlayerId(
        recipientPlayerId,
      );

      if (recipientUserId == null) {
        print(
          '‚ö†Ô∏è Cannot update unread count - user ID not found for player ID: $recipientPlayerId',
        );
        return;
      }

      // Check if user document exists before updating
      final userDoc =
          await FirebaseService.usersCollection.doc(recipientUserId).get();

      if (!userDoc.exists) {
        print(
          '‚ö†Ô∏è Cannot update unread count - user document does not exist: $recipientUserId',
        );
        return;
      }

      // Update unread count
      await FirebaseService.usersCollection.doc(recipientUserId).update({
        'unreadChats.$chatId': FieldValue.increment(1),
        'totalUnreadMessages': FieldValue.increment(1),
        'lastUnreadUpdate': FieldValue.serverTimestamp(),
      });

      print('‚úÖ Updated unread count for user: $recipientUserId');
    } catch (e) {
      print('‚ùå Error updating unread count: $e');
    }
  }

  // Get user ID from OneSignal player ID
  static Future<String?> _getRecipientUserIdFromPlayerId(
    String playerId,
  ) async {
    try {
      print('üîç Looking up user ID for player ID: $playerId');

      // Query users collection to find user with this OneSignal player ID
      final querySnapshot =
          await FirebaseService.usersCollection
              .where('oneSignalPlayerId', isEqualTo: playerId)
              .limit(1)
              .get();

      if (querySnapshot.docs.isNotEmpty) {
        final userDoc = querySnapshot.docs.first;
        final userId = userDoc.id;
        print('‚úÖ Found user ID: $userId for player ID: $playerId');
        return userId;
      } else {
        print('‚ùå No user found with player ID: $playerId');
        return null;
      }
    } catch (e) {
      print('‚ùå Error getting user ID from player ID: $e');
      return null;
    }
  }

  // Clear unread count when user opens chat
  static Future<void> clearUnreadCount(String userId, String chatId) async {
    try {
      // Check if user document exists
      final userDoc = await FirebaseService.usersCollection.doc(userId).get();

      if (!userDoc.exists) {
        print(
          '‚ö†Ô∏è Cannot clear unread count - user document does not exist: $userId',
        );
        return;
      }

      final userData = userDoc.data() as Map<String, dynamic>;
      final unreadChats =
          userData['unreadChats'] as Map<String, dynamic>? ?? {};
      final currentUnreadForChat = unreadChats[chatId] as int? ?? 0;

      if (currentUnreadForChat > 0) {
        await FirebaseService.usersCollection.doc(userId).update({
          'unreadChats.$chatId': FieldValue.delete(),
          'totalUnreadMessages': FieldValue.increment(-currentUnreadForChat),
          'lastReadUpdate': FieldValue.serverTimestamp(),
        });

        print(
          '‚úÖ Cleared $currentUnreadForChat unread messages for chat: $chatId',
        );
      } else {
        print('üìã No unread messages to clear for chat: $chatId');
      }
    } catch (e) {
      print('‚ùå Error clearing unread count: $e');
    }
  }

  // Track user's current active chat
  static Future<void> setUserActiveChatId(String userId, String? chatId) async {
    try {
      // Check if user document exists
      final userDoc = await FirebaseService.usersCollection.doc(userId).get();

      if (!userDoc.exists) {
        print(
          '‚ö†Ô∏è Cannot set active chat - user document does not exist: $userId',
        );
        return;
      }

      await FirebaseService.usersCollection.doc(userId).update({
        'activeChatId': chatId,
        'lastChatActivity': FieldValue.serverTimestamp(),
      });

      // Also set locally
      setActiveChatId(chatId);

      print('‚úÖ Updated user active chat ID: $chatId for user: $userId');
    } catch (e) {
      print('‚ùå Error updating user active chat ID: $e');
    }
  }

  static Future<void> debugUserPlayerIdMapping() async {
    try {
      print('üîç Debugging user and player ID mapping...');

      final currentUserId = FirebaseService.currentUserId;
      if (currentUserId == null) {
        print('‚ùå No current user ID');
        return;
      }

      // Get current user document
      final currentUserDoc =
          await FirebaseService.usersCollection.doc(currentUserId).get();

      if (currentUserDoc.exists) {
        final userData = currentUserDoc.data() as Map<String, dynamic>;
        final currentUserPlayerId = userData['oneSignalPlayerId'] as String?;

        print('üìã Current user ID: $currentUserId');
        print('üìã Current user player ID: $currentUserPlayerId');
        print('üìã Current user name: ${userData['displayName']}');

        // Get partner info
        final partnerId = userData['partnerId'] as String?;
        if (partnerId != null) {
          final partnerDoc =
              await FirebaseService.usersCollection.doc(partnerId).get();

          if (partnerDoc.exists) {
            final partnerData = partnerDoc.data() as Map<String, dynamic>;
            final partnerPlayerId = partnerData['oneSignalPlayerId'] as String?;

            print('üìã Partner user ID: $partnerId');
            print('üìã Partner player ID: $partnerPlayerId');
            print('üìã Partner name: ${partnerData['displayName']}');

            // Test mapping both ways
            if (partnerPlayerId != null) {
              final mappedUserId = await _getRecipientUserIdFromPlayerId(
                partnerPlayerId,
              );
              print(
                'üìã Mapping test - Player ID $partnerPlayerId maps to User ID: $mappedUserId',
              );
            }
          } else {
            print('‚ùå Partner document not found: $partnerId');
          }
        } else {
          print('‚ö†Ô∏è No partner ID found for current user');
        }
      } else {
        print('‚ùå Current user document not found: $currentUserId');
      }
    } catch (e) {
      print('‚ùå Error in debug user player ID mapping: $e');
    }
  }

  // Set user app background state
  static Future<void> setUserAppBackgroundState(
    String userId,
    bool isInBackground,
  ) async {
    try {
      await FirebaseService.usersCollection.doc(userId).update({
        'isAppInBackground': isInBackground,
        'lastAppStateUpdate': FieldValue.serverTimestamp(),
      });

      // Also set locally
      setAppForegroundState(!isInBackground);

      print('‚úÖ Updated user app background state: $isInBackground');
    } catch (e) {
      print('‚ùå Error updating user app background state: $e');
    }
  }

  // Existing utility methods...
  static Future<bool> areNotificationsEnabled() async {
    try {
      final permission = await OneSignal.Notifications.permission;
      return permission;
    } catch (e) {
      print('‚ùå Error checking notification permission: $e');
      return false;
    }
  }

  static Future<bool> requestNotificationPermission() async {
    try {
      final permission = await OneSignal.Notifications.requestPermission(true);

      if (permission) {
        await updateUserPlayerId();
        print('‚úÖ Notification permission granted');
      } else {
        print('‚ö†Ô∏è Notification permission denied');
      }

      return permission;
    } catch (e) {
      print('‚ùå Error requesting notification permission: $e');
      return false;
    }
  }

  static Future<void> clearAllNotifications() async {
    try {
      await OneSignal.Notifications.clearAll();
      print('‚úÖ All notifications cleared');
    } catch (e) {
      print('‚ùå Error clearing notifications: $e');
    }
  }

  static Future<Map<String, dynamic>> getNotificationSettings() async {
    try {
      final permission = await areNotificationsEnabled();
      final playerId = await getPlayerId();

      return {
        'permission': permission,
        'playerId': playerId,
        'oneSignalAppId': _oneSignalAppId,
        'restApiKey': '${_oneSignalRestApiKey.substring(0, 8)}...',
        'sdkVersion': 'OneSignal Flutter SDK',
        'timestamp': DateTime.now().toIso8601String(),
      };
    } catch (e) {
      print('‚ùå Error getting notification settings: $e');
      return {};
    }
  }

  static Future<void> debugNotificationSetup() async {
    try {
      print('üîç Debugging OneSignal setup with REST API...');

      final settings = await getNotificationSettings();
      print('üìã Notification settings: $settings');

      final permission = await areNotificationsEnabled();
      print('üìã Permission granted: $permission');

      final playerId = await getPlayerId();
      print('üìã Player ID: $playerId');

      if (playerId == null) {
        print('‚ö†Ô∏è No player ID - trying to initialize...');
        await updateUserPlayerId();
      }

      if (playerId != null) {
        print('üß™ Testing INSTANT notification via REST API...');
        final success = await sendInstantMessageNotification(
          recipientPlayerId: playerId,
          senderName: 'Debug Test',
          message: 'üöÄ Testing instant REST API notification!',
          chatId: 'debug_chat',
          senderId: 'debug_sender',
        );

        if (success) {
          print('‚úÖ REST API test notification sent successfully!');
        } else {
          print(
            '‚ùå REST API test notification failed - check your API key and setup',
          );
        }
      }
    } catch (e) {
      print('‚ùå Error in debug: $e');
    }
  }

  // Method to set external user ID for better user tracking
  static Future<void> setExternalUserId(String userId) async {
    try {
      OneSignal.login(userId);
      print('‚úÖ OneSignal external user ID set: $userId');
    } catch (e) {
      print('‚ùå Error setting OneSignal external user ID: $e');
    }
  }

  static Future<void> removeExternalUserId() async {
    try {
      OneSignal.logout();
      print('‚úÖ OneSignal external user ID removed');
    } catch (e) {
      print('‚ùå Error removing OneSignal external user ID: $e');
    }
  }

  // ENHANCED: Test REST API connection with proper authentication
  static Future<bool> testRestApiConnection() async {
    try {
      print('üß™ Testing OneSignal REST API connection...');
      print('üîë API Key Length: ${_oneSignalRestApiKey.length}');
      print('üîë API Key Format Valid: ${_isValidApiKey(_oneSignalRestApiKey)}');

      if (!_isValidApiKey(_oneSignalRestApiKey)) {
        print('‚ùå Invalid API key format - must be 20+ characters');
        return false;
      }

      // Test with app info endpoint first
      print('üì° Testing with app info endpoint...');
      final appResponse = await http.get(
        Uri.parse('https://onesignal.com/api/v1/apps/$_oneSignalAppId'),
        headers: {
          'Authorization': 'Basic $_oneSignalRestApiKey',
          'Accept': 'application/json',
        },
      );

      print('üìã App Info Response Status: ${appResponse.statusCode}');
      print('üìã App Info Response Body: ${appResponse.body}');

      if (appResponse.statusCode == 200) {
        print('‚úÖ REST API connection successful!');
        final appData = jsonDecode(appResponse.body);
        print('üì± App Name: ${appData['name']}');
        print('üì± App ID: ${appData['id']}');
        return true;
      } else if (appResponse.statusCode == 403) {
        print('‚ùå API Key authentication failed (403)');
        print('‚ùå This usually means:');
        print('   1. Invalid API key');
        print('   2. API key doesn\'t have permission for this app');
        print('   3. Using User Auth Key instead of REST API Key');
        return false;
      } else {
        print('‚ùå REST API connection failed: ${appResponse.statusCode}');
        print('‚ùå Response: ${appResponse.body}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error testing REST API connection: $e');
      return false;
    }
  }

  // üîë HELP METHOD: Check API key and provide instructions
  static void checkApiKeySetup() {
    print('üîë ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    print('üîë ONESIGNAL API KEY SETUP CHECK');
    print('üîë ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    print('üìã Current API Key: $_oneSignalRestApiKey');
    print('üìã Key Length: ${_oneSignalRestApiKey.length}');
    print('üìã Key Format Valid: ${_isValidApiKey(_oneSignalRestApiKey)}');
    print('üìã App ID: $_oneSignalAppId');
    print('');
    print('‚ùó POSSIBLE ISSUES:');
    print('1. Using USER AUTH KEY instead of REST API KEY');
    print('2. API key doesn\'t have permission for this app');
    print('3. API key is invalid or expired');
    print('');
    print('üîß HOW TO GET CORRECT API KEY:');
    print('1. Go to OneSignal Dashboard');
    print('2. Select your app: $_oneSignalAppId');
    print('3. Go to Settings > Keys & IDs');
    print('4. Copy the "REST API Key" (NOT User Auth Key)');
    print('5. REST API Key should be ~50 characters long');
    print('');
    print('üì± Current app ID seems correct: $_oneSignalAppId');
    print('üîë But API key might be wrong: $_oneSignalRestApiKey');
    print('');
    print('üß™ Run testRestApiConnection() to verify');
    print('üîë ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  }

  // üîë METHOD: Test with custom API key
  static Future<bool> testWithCustomApiKey(String customApiKey) async {
    try {
      print('üß™ Testing with custom API key...');
      print('üîë Custom Key Length: ${customApiKey.length}');

      if (!_isValidApiKey(customApiKey)) {
        print('‚ùå Custom API key format invalid');
        return false;
      }

      final response = await http.get(
        Uri.parse('https://onesignal.com/api/v1/apps/$_oneSignalAppId'),
        headers: {
          'Authorization': 'Basic $customApiKey',
          'Accept': 'application/json',
        },
      );

      print('üìã Custom Key Test Status: ${response.statusCode}');

      if (response.statusCode == 200) {
        print('‚úÖ Custom API key works!');
        print('üîß Replace the API key in your code with: $customApiKey');
        return true;
      } else {
        print('‚ùå Custom API key failed: ${response.statusCode}');
        print('‚ùå Response: ${response.body}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error testing custom API key: $e');
      return false;
    }
  }

  static Future<Map<String, dynamic>?> getNotificationReport(
    String notificationId,
  ) async {
    try {
      print('üìä Getting notification report for: $notificationId');

      final response = await http.get(
        Uri.parse(
          'https://onesignal.com/api/v1/notifications/$notificationId?app_id=$_oneSignalAppId',
        ),
        headers: {'Authorization': 'Basic $_oneSignalRestApiKey'},
      );

      if (response.statusCode == 200) {
        final reportData = jsonDecode(response.body);
        print('‚úÖ Notification report retrieved');
        print('üìä Successful: ${reportData['successful']}');
        print('üìä Failed: ${reportData['failed']}');
        print('üìä Converted: ${reportData['converted']}');
        return reportData;
      } else {
        print('‚ùå Failed to get notification report: ${response.statusCode}');
        return null;
      }
    } catch (e) {
      print('‚ùå Error getting notification report: $e');
      return null;
    }
  }

  // ENHANCED: Cancel a scheduled notification
  static Future<bool> cancelNotification(String notificationId) async {
    try {
      print('üóëÔ∏è Cancelling notification: $notificationId');

      final response = await http.delete(
        Uri.parse(
          'https://onesignal.com/api/v1/notifications/$notificationId?app_id=$_oneSignalAppId',
        ),
        headers: {'Authorization': 'Basic $_oneSignalRestApiKey'},
      );

      if (response.statusCode == 200) {
        print('‚úÖ Notification cancelled successfully');
        return true;
      } else {
        print('‚ùå Failed to cancel notification: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      print('‚ùå Error cancelling notification: $e');
      return false;
    }
  }

  // ENHANCED: Schedule a notification for later
  static Future<String?> scheduleNotification({
    required String recipientPlayerId,
    required String title,
    required String message,
    required DateTime sendTime,
    required Map<String, dynamic> additionalData,
  }) async {
    try {
      print('‚è∞ Scheduling notification for: $sendTime');

      final Map<String, dynamic> notificationPayload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': [recipientPlayerId],
        'headings': {'en': title},
        'contents': {'en': message},
        'data': additionalData,
        'send_after': sendTime.toUtc().toIso8601String(),
        'priority': 10,
        'ttl': 259200,
        // Remove android_channel_id for compatibility
      };

      final response = await http.post(
        Uri.parse(_oneSignalApiUrl),
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Authorization': 'Basic $_oneSignalRestApiKey',
        },
        body: jsonEncode(notificationPayload),
      );

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        final notificationId = responseData['id'];
        print('‚úÖ Notification scheduled successfully: $notificationId');
        return notificationId;
      } else {
        print('‚ùå Failed to schedule notification: ${response.statusCode}');
        return null;
      }
    } catch (e) {
      print('‚ùå Error scheduling notification: $e');
      return null;
    }
  }

  // üß™ COMPREHENSIVE TEST METHOD - Call this from your screen
  static Future<Map<String, dynamic>> runComprehensiveNotificationTest({
    String? testPlayerId,
    String? testMessage,
  }) async {
    final Map<String, dynamic> testResults = {
      'timestamp': DateTime.now().toIso8601String(),
      'tests': <String, dynamic>{},
      'overall_success': false,
    };

    try {
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      print('üß™ COMPREHENSIVE NOTIFICATION TEST STARTED');
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

      // Test 1: Check OneSignal initialization
      print('\nüîç TEST 1: OneSignal Initialization');
      try {
        final playerId = await getPlayerId();
        if (playerId != null) {
          testResults['tests']['initialization'] = {
            'success': true,
            'playerId': playerId,
            'message': 'OneSignal initialized successfully',
          };
          print('‚úÖ OneSignal Player ID: $playerId');
        } else {
          testResults['tests']['initialization'] = {
            'success': false,
            'message': 'Could not get OneSignal Player ID',
          };
          print('‚ùå Could not get OneSignal Player ID');
        }
      } catch (e) {
        testResults['tests']['initialization'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Initialization error: $e');
      }

      // Test 2: Check notification permissions
      print('\nüîç TEST 2: Notification Permissions');
      try {
        final hasPermission = await areNotificationsEnabled();
        testResults['tests']['permissions'] = {
          'success': hasPermission,
          'hasPermission': hasPermission,
          'message':
              hasPermission
                  ? 'Notifications enabled'
                  : 'Notifications disabled',
        };
        print(
          hasPermission
              ? '‚úÖ Notifications enabled'
              : '‚ùå Notifications disabled',
        );
      } catch (e) {
        testResults['tests']['permissions'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Permission check error: $e');
      }

      // Test 3: Test REST API connection
      print('\nüîç TEST 3: REST API Connection');
      try {
        final apiSuccess = await testRestApiConnection();
        testResults['tests']['api_connection'] = {
          'success': apiSuccess,
          'message':
              apiSuccess
                  ? 'REST API connection successful'
                  : 'REST API connection failed',
        };
        print(
          apiSuccess
              ? '‚úÖ REST API connection successful'
              : '‚ùå REST API connection failed',
        );
      } catch (e) {
        testResults['tests']['api_connection'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå API connection error: $e');
      }

      // Test 4: Get current user info
      print('\nüîç TEST 4: Current User Info');
      try {
        final currentUserId = FirebaseService.currentUserId;
        if (currentUserId != null) {
          final userDoc =
              await FirebaseService.usersCollection.doc(currentUserId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            final userPlayerId = userData['oneSignalPlayerId'] as String?;
            final userName = userData['displayName'] as String?;

            testResults['tests']['user_info'] = {
              'success': true,
              'userId': currentUserId,
              'playerId': userPlayerId,
              'displayName': userName,
              'message': 'User info retrieved successfully',
            };

            print('‚úÖ Current User ID: $currentUserId');
            print('‚úÖ Current User Player ID: $userPlayerId');
            print('‚úÖ Current User Name: $userName');
          } else {
            testResults['tests']['user_info'] = {
              'success': false,
              'message': 'User document not found',
            };
            print('‚ùå User document not found');
          }
        } else {
          testResults['tests']['user_info'] = {
            'success': false,
            'message': 'No current user ID',
          };
          print('‚ùå No current user ID');
        }
      } catch (e) {
        testResults['tests']['user_info'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå User info error: $e');
      }

      // Test 5: Get partner info
      print('\nüîç TEST 5: Partner Info');
      try {
        final currentUserId = FirebaseService.currentUserId;
        if (currentUserId != null) {
          final userDoc =
              await FirebaseService.usersCollection.doc(currentUserId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            final partnerId = userData['partnerId'] as String?;

            if (partnerId != null) {
              final partnerDoc =
                  await FirebaseService.usersCollection.doc(partnerId).get();
              if (partnerDoc.exists) {
                final partnerData = partnerDoc.data() as Map<String, dynamic>;
                final partnerPlayerId =
                    partnerData['oneSignalPlayerId'] as String?;
                final partnerName = partnerData['displayName'] as String?;

                testResults['tests']['partner_info'] = {
                  'success': true,
                  'partnerId': partnerId,
                  'partnerPlayerId': partnerPlayerId,
                  'partnerName': partnerName,
                  'message': 'Partner info retrieved successfully',
                };

                print('‚úÖ Partner ID: $partnerId');
                print('‚úÖ Partner Player ID: $partnerPlayerId');
                print('‚úÖ Partner Name: $partnerName');
              } else {
                testResults['tests']['partner_info'] = {
                  'success': false,
                  'message': 'Partner document not found',
                };
                print('‚ùå Partner document not found');
              }
            } else {
              testResults['tests']['partner_info'] = {
                'success': false,
                'message': 'No partner ID in user document',
              };
              print('‚ùå No partner ID in user document');
            }
          }
        }
      } catch (e) {
        testResults['tests']['partner_info'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Partner info error: $e');
      }

      // Test 6: Test notification to self (if no test player ID provided)
      print('\nüîç TEST 6: Self Notification Test');
      try {
        final currentUserId = FirebaseService.currentUserId;
        String? targetPlayerId = testPlayerId;

        // If no test player ID provided, use current user's player ID
        if (targetPlayerId == null && currentUserId != null) {
          final userDoc =
              await FirebaseService.usersCollection.doc(currentUserId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            targetPlayerId = userData['oneSignalPlayerId'] as String?;
          }
        }

        if (targetPlayerId != null) {
          final testMsg =
              testMessage ??
              'üß™ Test notification from ${DateTime.now().toIso8601String()}';

          print('üì§ Sending test notification to: $targetPlayerId');
          print('üìù Test message: $testMsg');

          final success = await sendInstantMessageNotification(
            recipientPlayerId: targetPlayerId,
            senderName: 'Test Sender',
            message: testMsg,
            chatId: 'test_chat_${DateTime.now().millisecondsSinceEpoch}',
            senderId: currentUserId ?? 'test_sender',
            skipPresenceCheck: true, // Skip presence check for testing
          );

          testResults['tests']['self_notification'] = {
            'success': success,
            'targetPlayerId': targetPlayerId,
            'testMessage': testMsg,
            'message':
                success
                    ? 'Test notification sent successfully'
                    : 'Test notification failed',
          };

          print(
            success
                ? '‚úÖ Test notification sent successfully!'
                : '‚ùå Test notification failed',
          );
        } else {
          testResults['tests']['self_notification'] = {
            'success': false,
            'message': 'No target player ID available for testing',
          };
          print('‚ùå No target player ID available for testing');
        }
      } catch (e) {
        testResults['tests']['self_notification'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Self notification test error: $e');
      }

      // Test 7: Test notification to partner (if available)
      print('\nüîç TEST 7: Partner Notification Test');
      try {
        final currentUserId = FirebaseService.currentUserId;
        if (currentUserId != null) {
          final userDoc =
              await FirebaseService.usersCollection.doc(currentUserId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            final partnerId = userData['partnerId'] as String?;

            if (partnerId != null) {
              final partnerDoc =
                  await FirebaseService.usersCollection.doc(partnerId).get();
              if (partnerDoc.exists) {
                final partnerData = partnerDoc.data() as Map<String, dynamic>;
                final partnerPlayerId =
                    partnerData['oneSignalPlayerId'] as String?;
                final currentUserName =
                    userData['displayName'] as String? ?? 'Test User';

                if (partnerPlayerId != null) {
                  final testMsg =
                      testMessage ??
                      'üß™ Test notification to partner from ${DateTime.now().toIso8601String()}';

                  print(
                    'üì§ Sending test notification to partner: $partnerPlayerId',
                  );
                  print('üìù Test message: $testMsg');

                  final success = await sendInstantMessageNotification(
                    recipientPlayerId: partnerPlayerId,
                    senderName: currentUserName,
                    message: testMsg,
                    chatId:
                        'test_partner_chat_${DateTime.now().millisecondsSinceEpoch}',
                    senderId: currentUserId,
                    skipPresenceCheck: true, // Skip presence check for testing
                  );

                  testResults['tests']['partner_notification'] = {
                    'success': success,
                    'partnerPlayerId': partnerPlayerId,
                    'testMessage': testMsg,
                    'message':
                        success
                            ? 'Partner notification sent successfully'
                            : 'Partner notification failed',
                  };

                  print(
                    success
                        ? '‚úÖ Partner notification sent successfully!'
                        : '‚ùå Partner notification failed',
                  );
                } else {
                  testResults['tests']['partner_notification'] = {
                    'success': false,
                    'message': 'Partner has no OneSignal player ID',
                  };
                  print('‚ùå Partner has no OneSignal player ID');
                }
              }
            } else {
              testResults['tests']['partner_notification'] = {
                'success': false,
                'message': 'No partner available for testing',
              };
              print('‚ÑπÔ∏è No partner available for testing');
            }
          }
        }
      } catch (e) {
        testResults['tests']['partner_notification'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Partner notification test error: $e');
      }

      // Test 8: Test typing notification
      print('\nüîç TEST 8: Typing Notification Test');
      try {
        final currentUserId = FirebaseService.currentUserId;
        String? targetPlayerId = testPlayerId;

        // Use current user's player ID if no test ID provided
        if (targetPlayerId == null && currentUserId != null) {
          final userDoc =
              await FirebaseService.usersCollection.doc(currentUserId).get();
          if (userDoc.exists) {
            final userData = userDoc.data() as Map<String, dynamic>;
            targetPlayerId = userData['oneSignalPlayerId'] as String?;
          }
        }

        if (targetPlayerId != null) {
          print('üì§ Sending typing notification to: $targetPlayerId');

          final success = await sendTypingNotification(
            recipientPlayerId: targetPlayerId,
            senderName: 'Test Typer',
            chatId: 'test_typing_chat_${DateTime.now().millisecondsSinceEpoch}',
            senderId: currentUserId ?? 'test_sender',
          );

          testResults['tests']['typing_notification'] = {
            'success': success,
            'targetPlayerId': targetPlayerId,
            'message':
                success
                    ? 'Typing notification sent successfully'
                    : 'Typing notification failed',
          };

          print(
            success
                ? '‚úÖ Typing notification sent successfully!'
                : '‚ùå Typing notification failed',
          );
        } else {
          testResults['tests']['typing_notification'] = {
            'success': false,
            'message': 'No target player ID available for typing test',
          };
          print('‚ùå No target player ID available for typing test');
        }
      } catch (e) {
        testResults['tests']['typing_notification'] = {
          'success': false,
          'error': e.toString(),
        };
        print('‚ùå Typing notification test error: $e');
      }

      // Calculate overall success
      final successfulTests =
          testResults['tests'].values
              .where((test) => test is Map && test['success'] == true)
              .length;
      final totalTests = testResults['tests'].length;
      testResults['overall_success'] =
          successfulTests >= (totalTests * 0.6); // 60% success rate
      testResults['success_rate'] = '$successfulTests/$totalTests';

      print('\nüß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      print('üß™ TEST RESULTS SUMMARY');
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      print('üìä Tests passed: $successfulTests/$totalTests');
      print(
        'üìä Success rate: ${((successfulTests / totalTests) * 100).toStringAsFixed(1)}%',
      );
      print('üìä Overall success: ${testResults['overall_success']}');
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

      return testResults;
    } catch (e, stackTrace) {
      print('‚ùå Comprehensive test error: $e');
      print('‚ùå Stack trace: $stackTrace');

      testResults['tests']['test_framework'] = {
        'success': false,
        'error': e.toString(),
        'stackTrace': stackTrace.toString(),
      };

      return testResults;
    }
  }

  // üß™ FORCE SEND - Bypass all presence checks and send notification
  static Future<bool> forceSendNotification({
    required String recipientPlayerId,
    required String senderName,
    required String message,
    required String chatId,
    required String senderId,
  }) async {
    try {
      print('üöÄ FORCE SENDING notification (bypassing all checks)...');
      print('üìù To Player ID: $recipientPlayerId');
      print('üìù From: $senderName');
      print('üìù Message: $message');

      // Format message for notification
      String notificationMessage = message;
      if (message.length > 100) {
        notificationMessage = '${message.substring(0, 97)}...';
      }

      // Handle special message types
      if (message.startsWith('üì∑')) {
        notificationMessage = 'üì∑ Sent a photo';
      } else if (message.isEmpty) {
        notificationMessage = 'Sent a message';
      }

      print('üîß Creating force notification payload...');

      // Create notification payload for OneSignal REST API
      final Map<String, dynamic> notificationPayload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': [recipientPlayerId],
        'headings': {'en': 'üíï $senderName'},
        'contents': {'en': notificationMessage},
        'data': {
          'type': 'new_message',
          'chatId': chatId,
          'senderId': senderId,
          'senderName': senderName,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
          'messagePreview': notificationMessage,
        },
        'priority': 10,
        'ttl': 259200,
        'android_accent_color': 'FF9C27B0',
        'android_led_color': 'FF9C27B0',
        'android_sound': 'default',
        'ios_sound': 'default',
        'ios_badgeType': 'Increase',
        'ios_badgeCount': 1,
      };

      print('üì° Force sending HTTP request to OneSignal...');
      print('üîó URL: $_oneSignalApiUrl');
      print('üîë API Key Length: ${_oneSignalRestApiKey.length}');
      print('üì¶ Payload: ${jsonEncode(notificationPayload)}');

      print('üöÄ Making FORCE HTTP POST request...');

      // Send notification via REST API with timeout
      final response = await http
          .post(
            Uri.parse(_oneSignalApiUrl),
            headers: {
              'Content-Type': 'application/json; charset=utf-8',
              'Authorization': 'Basic $_oneSignalRestApiKey',
              'Accept': 'application/json',
            },
            body: jsonEncode(notificationPayload),
          )
          .timeout(
            const Duration(seconds: 30),
            onTimeout: () {
              print('‚è∞ FORCE HTTP request timed out after 30 seconds');
              throw Exception('Request timed out');
            },
          );

      print('üì® FORCE HTTP request completed!');
      print('üìã HTTP Response Status: ${response.statusCode}');
      print('üìã HTTP Response Headers: ${response.headers}');
      print('üìã HTTP Response Body: ${response.body}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        print('‚úÖ FORCE NOTIFICATION SENT SUCCESSFULLY!');
        print('üìä OneSignal ID: ${responseData['id']}');
        print('üìä Recipients: ${responseData['recipients']}');
        print('üìä External ID: ${responseData['external_id']}');

        return true;
      } else {
        print('‚ùå FORCE notification failed: ${response.statusCode}');
        print('‚ùå Response Headers: ${response.headers}');
        print('‚ùå Response Body: ${response.body}');

        // Try to parse error response
        try {
          final errorData = jsonDecode(response.body);
          if (errorData['errors'] != null) {
            print('‚ùå OneSignal Errors: ${errorData['errors']}');
          }
        } catch (e) {
          print('‚ùå Could not parse error response: $e');
        }

        return false;
      }
    } catch (e, stackTrace) {
      print('‚ùå Error in force send notification: $e');
      print('‚ùå Stack trace: $stackTrace');
      return false;
    }
  }

  static Future<bool> sendDirectTestNotification(
    String playerID,
    String message,
  ) async {
    try {
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      print('üß™ DIRECT TEST NOTIFICATION');
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      print('üìù Target Player ID: $playerID');
      print('üìù Test Message: $message');

      // Create the simplest possible notification payload
      final Map<String, dynamic> payload = {
        'app_id': _oneSignalAppId,
        'include_player_ids': [playerID],
        'contents': {'en': message},
        'headings': {'en': 'Direct Test'},
      };

      print('üì¶ Simple Payload: ${jsonEncode(payload)}');
      print('üöÄ Sending direct HTTP request...');

      final response = await http
          .post(
            Uri.parse(_oneSignalApiUrl),
            headers: {
              'Content-Type': 'application/json; charset=utf-8',
              'Authorization': 'Basic $_oneSignalRestApiKey',
              'Accept': 'application/json',
            },
            body: jsonEncode(payload),
          )
          .timeout(const Duration(seconds: 30));

      print('üì® Direct test response received!');
      print('üìã Status: ${response.statusCode}');
      print('üìã Body: ${response.body}');
      print('üìã Headers: ${response.headers}');

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        print('‚úÖ DIRECT TEST SUCCESS!');
        print('üìä Notification ID: ${responseData['id']}');
        print('üìä Recipients: ${responseData['recipients']}');
        print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        return true;
      } else {
        print('‚ùå DIRECT TEST FAILED!');
        print('‚ùå Status: ${response.statusCode}');
        print('‚ùå Error: ${response.body}');
        print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        return false;
      }
    } catch (e, stackTrace) {
      print('‚ùå DIRECT TEST EXCEPTION: $e');
      print('‚ùå Stack trace: $stackTrace');
      print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      return false;
    }
  }

  // üß™ COMPREHENSIVE DEBUG METHOD
  static Future<void> debugEverything() async {
    print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    print('üß™ COMPREHENSIVE DEBUG SESSION');
    print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    try {
      // 1. Check current user
      final currentUserId = FirebaseService.currentUserId;
      print('üë§ Current User ID: $currentUserId');

      if (currentUserId != null) {
        final userDoc =
            await FirebaseService.usersCollection.doc(currentUserId).get();
        if (userDoc.exists) {
          final userData = userDoc.data() as Map<String, dynamic>;
          final currentUserPlayerId = userData['oneSignalPlayerId'] as String?;
          final userName = userData['displayName'] as String?;
          final partnerId = userData['partnerId'] as String?;

          print('üë§ Current User Name: $userName');
          print('üë§ Current User Player ID: $currentUserPlayerId');
          print('üë§ Partner ID: $partnerId');

          // 2. Check partner
          if (partnerId != null) {
            final partnerDoc =
                await FirebaseService.usersCollection.doc(partnerId).get();
            if (partnerDoc.exists) {
              final partnerData = partnerDoc.data() as Map<String, dynamic>;
              final partnerPlayerId =
                  partnerData['oneSignalPlayerId'] as String?;
              final partnerName = partnerData['displayName'] as String?;

              print('üë• Partner Name: $partnerName');
              print('üë• Partner Player ID: $partnerPlayerId');

              // 3. Test direct notification to partner
              if (partnerPlayerId != null) {
                print('\nüß™ Testing direct notification to partner...');
                final partnerSuccess = await sendDirectTestNotification(
                  partnerPlayerId,
                  'üß™ Direct test to partner - ${DateTime.now().millisecondsSinceEpoch}',
                );
                print('üë• Partner test result: $partnerSuccess');
              }
            }
          }

          // 4. Test direct notification to self
          if (currentUserPlayerId != null) {
            print('\nüß™ Testing direct notification to self...');
            final selfSuccess = await sendDirectTestNotification(
              currentUserPlayerId,
              'üß™ Direct test to self - ${DateTime.now().millisecondsSinceEpoch}',
            );
            print('üë§ Self test result: $selfSuccess');
          }
        }
      }

      // 5. Test API connection
      print('\nüß™ Testing API connection...');
      final apiSuccess = await testRestApiConnection();
      print('üîó API test result: $apiSuccess');
    } catch (e, stackTrace) {
      print('‚ùå Debug session error: $e');
      print('‚ùå Stack trace: $stackTrace');
    }

    print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    print('üß™ DEBUG SESSION COMPLETE');
    print('üß™ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  }

  static Future<bool> testNotificationToSelf({String? customMessage}) async {
    try {
      print('üß™ Testing notification to self...');

      final currentUserId = FirebaseService.currentUserId;
      if (currentUserId == null) {
        print('‚ùå No current user ID');
        return false;
      }

      final userDoc =
          await FirebaseService.usersCollection.doc(currentUserId).get();
      if (!userDoc.exists) {
        print('‚ùå User document not found');
        return false;
      }

      final userData = userDoc.data() as Map<String, dynamic>;
      final playerId = userData['oneSignalPlayerId'] as String?;
      final userName = userData['displayName'] as String? ?? 'Test User';

      if (playerId == null) {
        print('‚ùå No OneSignal player ID found');
        return false;
      }

      final testMessage =
          customMessage ??
          'üß™ Test notification - ${DateTime.now().toIso8601String()}';

      print('üì§ Sending test notification...');
      print('üìù Player ID: $playerId');
      print('üìù Message: $testMessage');

      final success = await sendInstantMessageNotification(
        recipientPlayerId: playerId,
        senderName: userName,
        message: testMessage,
        chatId: 'self_test_${DateTime.now().millisecondsSinceEpoch}',
        senderId: currentUserId,
        skipPresenceCheck: true,
      );

      print(
        success
            ? '‚úÖ Self test notification sent!'
            : '‚ùå Self test notification failed!',
      );
      return success;
    } catch (e) {
      print('‚ùå Self test error: $e');
      return false;
    }
  }

  // üß™ TEST NOTIFICATION TO PARTNER - Call this to test partner notifications
  static Future<bool> testNotificationToPartner({String? customMessage}) async {
    try {
      print('üß™ Testing notification to partner...');

      final currentUserId = FirebaseService.currentUserId;
      if (currentUserId == null) {
        print('‚ùå No current user ID');
        return false;
      }

      final userDoc =
          await FirebaseService.usersCollection.doc(currentUserId).get();
      if (!userDoc.exists) {
        print('‚ùå User document not found');
        return false;
      }

      final userData = userDoc.data() as Map<String, dynamic>;
      final partnerId = userData['partnerId'] as String?;
      final currentUserName = userData['displayName'] as String? ?? 'Test User';

      if (partnerId == null) {
        print('‚ùå No partner ID found');
        return false;
      }

      final partnerDoc =
          await FirebaseService.usersCollection.doc(partnerId).get();
      if (!partnerDoc.exists) {
        print('‚ùå Partner document not found');
        return false;
      }

      final partnerData = partnerDoc.data() as Map<String, dynamic>;
      final partnerPlayerId = partnerData['oneSignalPlayerId'] as String?;

      if (partnerPlayerId == null) {
        print('‚ùå Partner has no OneSignal player ID');
        return false;
      }

      final testMessage =
          customMessage ??
          'üß™ Test notification to partner - ${DateTime.now().toIso8601String()}';

      print('üì§ Sending test notification to partner...');
      print('üìù Partner Player ID: $partnerPlayerId');
      print('üìù Message: $testMessage');

      final success = await sendInstantMessageNotification(
        recipientPlayerId: partnerPlayerId,
        senderName: currentUserName,
        message: testMessage,
        chatId: 'partner_test_${DateTime.now().millisecondsSinceEpoch}',
        senderId: currentUserId,
        skipPresenceCheck: true,
      );

      print(
        success
            ? '‚úÖ Partner test notification sent!'
            : '‚ùå Partner test notification failed!',
      );
      return success;
    } catch (e) {
      print('‚ùå Partner test error: $e');
      return false;
    }

    print('üìö ENHANCED NOTIFICATION SERVICE USAGE:');
    print('');
    print('üöÄ INSTANT NOTIFICATIONS (Primary Method):');
    print('NotificationService.sendInstantMessageNotification(');
    print('  recipientPlayerId: "player-id",');
    print('  senderName: "John",');
    print('  message: "Hello!",');
    print('  chatId: "chat-123",');
    print('  senderId: "user-456"');
    print(');');
    print('');
    print('üì± FALLBACK (Automatic):');
    print('NotificationService.sendMessageNotification(');
    print('  // Same parameters - will try REST API first, then Firestore');
    print(');');
    print('');
    print('‚úçÔ∏è TYPING NOTIFICATIONS:');
    print('NotificationService.sendTypingNotification(');
    print('  recipientPlayerId: "player-id",');
    print('  senderName: "John",');
    print('  chatId: "chat-123",');
    print('  senderId: "user-456"');
    print(');');
    print('');
    print('üß™ TESTING:');
    print('await NotificationService.testRestApiConnection();');
    print('await NotificationService.debugNotificationSetup();');
    print('');
    print('‚ö†Ô∏è IMPORTANT: Add http package to pubspec.yaml:');
    print('dependencies:');
    print('  http: ^1.1.0');
  }
}
